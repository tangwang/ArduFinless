# 03｜代码导读与控制流程（带关键代码索引）

> 本文是“把仓库代码讲成一条可跟踪的数据流”。建议开着 `ArduFinless.ino` 对照阅读。

## 1. 主程序入口：`setup()` 与 `loop()`

`setup()` 负责一次性初始化：
- 串口启动（115200）
- EEPROM 载入参数
- PWM IO 初始化
- SPI 与传感器初始化
- 打开输出通道

`loop()` 负责实时循环（目标 100Hz）：
- 串口命令处理
- PWM 输入超时检查
- 读取传感器与遥控输入
- 滤波
- 控制律计算
- PWM 输出
- 可选调试打印

## 2. 输入采集：传感器 + RC

### 2.1 编码器角度（Beta）

`readEncoderAngle()` 的流程：
1. 调用驱动读取角度。
2. 加上 `encoder_calibration`。
3. 调用 `normalizeAngle()` 归一化到 `[-180, 180]`。

这使控制律中 Beta 有统一的数学意义。

### 2.2 陀螺仪角速度（Yaw Rate）

`readGyroRate()` 从 `imu.get_gyro_z()` 取 Z 轴角速度，并叠加 `gyro_calibration` 进行零偏修正。

### 2.3 RC 输入归一化

`readPWMInputs()` 将脉宽线性映射为 `[-1,1]`，并在无效输入时回到 0。
这是一种典型“故障降级”：输入失效时尽量不注入额外控制。

## 3. 低通滤波与采样频率

主程序定义采样时间 `SAMPLE_TIME = 0.01s`（即 100Hz）。
滤波器实例对应 Beta、Yaw Rate、Yaw、Brake（当前 Yaw 变量保留了不滤波路径）。

滤波器实现是一阶离散低通：
- 系数由截止频率与采样时间算出。
- 每次 `update()` 输出平滑值。

## 4. 控制律：项目最核心的一段

核心控制项：

```cpp
control_term = - Yaw * Yaw_gain - Beta_norm * Cn_beta + Yaw_Rate_norm * Cn_damper;
```

可直观理解为：
- 第一项：执行你的偏航指令（Yaw）。
- 第二项：抑制侧滑偏差（Beta 反馈）。
- 第三项：提供动态阻尼（Yaw Rate 反馈）。

之后与 Brake 合成左右舵输出，并限制在 `[0,1]`。

## 5. 输出映射：归一化值到舵机脉宽

`setPWMOutputs()` 将 `OUT_right / OUT_left` 映射到各自脉宽限位区间（可调参数）。
这允许你在机械安装不同的情况下，仅通过参数完成适配。

## 6. 参数系统：为何适合入门调试

该项目的参数系统有三个优点：
1. **在线可调**：串口 `set/get/params/help`。
2. **范围保护**：每个参数有上下限校验。
3. **掉电保存**：写入 EEPROM，并通过 magic 校验读取合法性。

这正是“飞控调参闭环”的基本基础设施。

## 7. 底层驱动代码如何读

建议顺序：
1. `PWM_IO.h/.cpp`：先看通道定义，再看中断测宽与定时器输出。
2. `AS5047P.*`：看 SPI 读角与角度转换。
3. `MPU6500.*`：看初始化、WHO_AM_I 检测、数据块读取。
4. `LowPassFilter.*`：看一阶滤波公式实现。

一旦你能把这四块串起来，已经具备继续扩展控制算法的基础。
